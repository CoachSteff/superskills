#!/usr/bin/env python3
"""
Distribute credentials from root .env to skill-specific .env files.

This script automates syncing API credentials from the global .env file
to individual skill .env files for isolated credential management.
"""
import argparse
import os
import sys
from pathlib import Path

try:
    from dotenv import load_dotenv, dotenv_values
    DOTENV_AVAILABLE = True
except ImportError:
    DOTENV_AVAILABLE = False
    print("âš ï¸  python-dotenv not installed")
    print("   Install with: pip install python-dotenv")
    sys.exit(1)

# Skill â†’ Credential mapping
SKILL_CREDENTIALS = {
    "craft": [
        "CRAFT_API_ENDPOINT",
        "CRAFT_API_KEY"
    ],
    "designer": [
        "GEMINI_API_KEY",
        "MIDJOURNEY_API_KEY"
    ],
    "narrator": [
        "ELEVENLABS_API_KEY",
        "ELEVENLABS_VOICE_ID"
    ],
    "transcriber": [
        "OPENAI_API_KEY",
        "ASSEMBLYAI_API_KEY"
    ],
    "marketer": [
        "POSTIZ_API_KEY",
        "POSTIZ_WORKSPACE_ID"
    ],
    "emailcampaigner": [
        "SENDGRID_API_KEY",
        "SENDGRID_FROM_EMAIL"
    ],
    "planner": [
        "MICROSOFT_CLIENT_ID",
        "MICROSOFT_CLIENT_SECRET",
        "MICROSOFT_TENANT_ID",
        "MICROSOFT_APPLICATION_ID",
        "MICROSOFT_USER_EMAIL"
    ],
    "notion": [
        "NOTION_API_KEY"
    ]
}

def get_repo_root():
    """Find repository root directory."""
    script_dir = Path(__file__).parent
    return script_dir.parent

def load_root_env():
    """Load credentials from root .env file."""
    repo_root = get_repo_root()
    env_file = repo_root / ".env"
    
    if not env_file.exists():
        print(f"âŒ Root .env file not found at {env_file}")
        print(f"   Create one by running: cp .env.template .env")
        sys.exit(1)
    
    return dotenv_values(env_file), env_file

def get_skill_dir(skill_name):
    """Get skill directory path."""
    repo_root = get_repo_root()
    
    # Try superskills/ first
    skill_dir = repo_root / "superskills" / skill_name
    if skill_dir.exists():
        return skill_dir
    
    # Try new-skills/
    skill_dir = repo_root / "new-skills" / skill_name
    if skill_dir.exists():
        return skill_dir
    
    return None

def mask_credential(value):
    """Mask credential value for display."""
    if not value:
        return "NOT SET"
    
    if len(value) > 12:
        return value[:8] + "..." + value[-4:]
    elif len(value) > 8:
        return value[:8] + "..."
    else:
        return "***"

def backup_env_file(env_file):
    """Create backup of existing .env file."""
    if not env_file.exists():
        return None
    
    from datetime import datetime
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_file = env_file.parent / f".env.backup.{timestamp}"
    
    with open(env_file, 'r') as src:
        content = src.read()
    
    with open(backup_file, 'w') as dst:
        dst.write(content)
    
    return backup_file

def distribute_to_skill(skill_name, root_env, dry_run=False, backup=False, verbose=False):
    """Distribute credentials to a single skill."""
    skill_dir = get_skill_dir(skill_name)
    
    if not skill_dir:
        print(f"âŠ˜ {skill_name:20} Skill directory not found")
        return False
    
    if skill_name not in SKILL_CREDENTIALS:
        print(f"âŠ˜ {skill_name:20} No credential mapping defined")
        return False
    
    skill_env_file = skill_dir / ".env"
    credentials_to_copy = SKILL_CREDENTIALS[skill_name]
    
    # Find credentials that exist in root .env
    available_creds = {}
    missing_creds = []
    
    for cred_key in credentials_to_copy:
        if cred_key in root_env and root_env[cred_key]:
            available_creds[cred_key] = root_env[cred_key]
        else:
            missing_creds.append(cred_key)
    
    if not available_creds:
        print(f"âŠ˜ {skill_name:20} No credentials found in root .env")
        return False
    
    # Show what will be distributed
    print(f"ðŸ“¦ {skill_name:20} {len(available_creds)}/{len(credentials_to_copy)} credentials found")
    
    if verbose:
        for key, value in available_creds.items():
            print(f"   â†’ {key:30} {mask_credential(value)}")
        for key in missing_creds:
            print(f"   âœ— {key:30} NOT SET")
    
    if dry_run:
        print(f"   Would write to: {skill_env_file}")
        return True
    
    # Backup if requested
    if backup and skill_env_file.exists():
        backup_file = backup_env_file(skill_env_file)
        if backup_file:
            print(f"   ðŸ’¾ Backup created: {backup_file.name}")
    
    # Write credentials
    try:
        with open(skill_env_file, 'w') as f:
            f.write(f"# Auto-generated by distribute_credentials.py\n")
            f.write(f"# Skill: {skill_name}\n")
            f.write(f"# Source: root .env\n\n")
            
            for key, value in available_creds.items():
                f.write(f"{key}={value}\n")
            
            if missing_creds:
                f.write(f"\n# Missing credentials (not in root .env):\n")
                for key in missing_creds:
                    f.write(f"# {key}=\n")
        
        print(f"   âœ“ Written to: {skill_env_file}")
        return True
    
    except Exception as e:
        print(f"   âŒ Error writing file: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(
        description="Distribute credentials from root .env to skill-specific .env files"
    )
    parser.add_argument(
        "--skill",
        help="Distribute to specific skill only (e.g., 'craft', 'transcriber')"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview changes without writing files"
    )
    parser.add_argument(
        "--backup",
        action="store_true",
        help="Create backup of existing .env files before overwriting"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Show detailed credential information"
    )
    
    args = parser.parse_args()
    
    print("=" * 70)
    print(" SuperSkills Credential Distribution")
    print("=" * 70)
    print()
    
    if args.dry_run:
        print("ðŸ” DRY RUN MODE - No files will be modified")
        print()
    
    # Load root .env
    root_env, root_env_file = load_root_env()
    print(f"âœ“ Loaded {root_env_file}")
    print()
    
    # Determine which skills to process
    if args.skill:
        skills = [args.skill]
    else:
        skills = list(SKILL_CREDENTIALS.keys())
    
    # Distribute to each skill
    success_count = 0
    for skill_name in skills:
        if distribute_to_skill(skill_name, root_env, args.dry_run, args.backup, args.verbose):
            success_count += 1
        print()
    
    print("=" * 70)
    print(f"Summary: {success_count}/{len(skills)} skills {'would be ' if args.dry_run else ''}updated")
    print("=" * 70)
    print()
    
    if args.dry_run:
        print("ðŸ’¡ Run without --dry-run to apply changes")
    elif success_count > 0:
        print("âœ“ Credentials distributed successfully!")
        print()
        print("Next steps:")
        print("  1. Verify with: python scripts/validate_credentials.py")
        print("  2. Test APIs with: python scripts/test_api_connections.py")

if __name__ == "__main__":
    main()
